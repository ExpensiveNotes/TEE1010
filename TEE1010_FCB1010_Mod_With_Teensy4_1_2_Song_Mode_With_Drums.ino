/* FCB 1010 Teensy 4.1 Modification  ----- TEE1010 
   By John Melki-Wegner (aka Expensive Notes)
   Simple Mono Synth Version
   Three Modes:
   1. Synth - Press and release a pedal (1-8) for a note
   2. Latch Mode - Tap a Pedal to start a note - No need to hold it which is good for guitar players
   3. Arp Mode - Tap a pedal to initiate an arp - Arp pattern and length can be varied up to 8 notes
   4. Song Patterns. 100 song defined up to 32 note patterns. - Press Enter to Toggle Song and Edit modes on device - Use Pot 2 and 3 to change notes - Auto save to EEProm on leaving
   5. Drums with 11 patterns over 4 styles - Acoustic or Electronic Kit - Sub Oscillator
   Important change to reading pots. Changes can only occur after the pot is 'close' to it's previous value.
   That is you need to turn through the previous value. Allows each pot to have more than one task
*/

#include <EEPROM.h>

//=== Audio ========================================================================= Audio

// ********************
//Design Tool: https://www.pjrc.com/teensy/gui/
#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

// GUItool: begin automatically generated code
AudioPlayMemory          playMemCrash;   //xy=92,551
AudioPlayMemory          playMemRide;    //xy=94,607
AudioPlayMemory          playMemOHh;     //xy=98,506
AudioPlayMemory          playMemSnare;   //xy=99,336
AudioPlayMemory          playMemCHh;     //xy=102,454
AudioPlayMemory          playMemKick;    //xy=106,285
AudioSynthWaveform       waveformMain;      //xy=110,96
AudioSynthWaveform       waveformSub;      //xy=115,159
AudioSynthWaveform       waveformUnison;      //xy=117,205
AudioFilterLadder        ladderMain;        //xy=272,112
AudioFilterLadder        ladderUnison;        //xy=275,215
AudioEffectEnvelope      envelopeSub;      //xy=453,168
AudioEffectEnvelope      envelopeMain;      //xy=458,119
AudioMixer4              mixerDrums;         //xy=460,528
AudioEffectEnvelope      envelopeUnison;      //xy=466,220
AudioMixer4              mixerWaves;         //xy=655,176
AudioMixer4              mixerOut;         //xy=847,314
AudioOutputI2S           i2s2; //xy=1024,318
AudioConnection          patchCord1(playMemCrash, 0, mixerDrums, 2);
AudioConnection          patchCord2(playMemRide, 0, mixerDrums, 3);
AudioConnection          patchCord3(playMemOHh, 0, mixerDrums, 1);
AudioConnection          patchCord4(playMemSnare, 0, mixerOut, 2);
AudioConnection          patchCord5(playMemCHh, 0, mixerDrums, 0);
AudioConnection          patchCord6(playMemKick, 0, mixerOut, 1);
AudioConnection          patchCord7(waveformMain, 0, ladderMain, 0);
AudioConnection          patchCord8(waveformSub, envelopeSub);
AudioConnection          patchCord9(waveformUnison, 0, ladderUnison, 0);
AudioConnection          patchCord10(ladderMain, envelopeMain);
AudioConnection          patchCord11(ladderUnison, envelopeUnison);
AudioConnection          patchCord12(envelopeSub, 0, mixerWaves, 1);
AudioConnection          patchCord13(envelopeMain, 0, mixerWaves, 0);
AudioConnection          patchCord14(mixerDrums, 0, mixerOut, 3);
AudioConnection          patchCord15(envelopeUnison, 0, mixerWaves, 2);
AudioConnection          patchCord16(mixerWaves, 0, mixerOut, 0);
AudioConnection          patchCord17(mixerOut, 0, i2s2, 0);
AudioConnection          patchCord18(mixerOut, 0, i2s2, 1);
AudioControlSGTL5000     sgtl5000_1;     //xy=714,37
// GUItool: end automatically generated code

//== Drums Song Mode =========================================================================

//Sound files generated by wav2sketch program. https://www.pjrc.com/teensy/gui/?info=AudioPlayMemory
#include "AcousticKick.h"
#include "AcousticSnare.h"
#include "AcousticClosedhihat.h"
#include "AcousticOpenhihat.h"
#include "AcousticCrashcymbal.h"
#include "AcousticRidecymbal.h"

//avoid variable names starting with numbers!
#include "606Kick.h"
#include "606Snare.h"
#include "606Closedhihat.h"
#include "606Openhihat.h"
#include "606Lowtom.h"
#include "606Hightom.h"

bool drumsOn = false; //Are drums and synth playing
bool acousticDrums = true; //or electronic 606
//Using Character strings to store drum patterns so they are easy to make while coding
int barLength [5] = {24, 16, 24, 16, 16}; //for drums only
int beatType = 1; //see next line
char beatString [5] [6] = {"3/4", "4/4", "12/8", "Jazz", "Elec"};
// for 4/4 use 16 beats. See barlength above. You could probably make your own...
char kickSequence[] =      "........................";
char snareSequence[] =     "........................";
char hiHatSequence[] =     "........................";
char openHiHatSequence[] = "........................";
char crashSequence[] =     "........................";// also low tom in electronic kit
char rideSequence[] =      "........................";// also High tom in electronic kit

bool countIn = false; //standard count in for 4/4
int complexity = 4; //Drum pattern complexity. Goes from 0 to 11
int beatNum = 0;
float swing = 1.0;
float swingAdjustment = 1.0;
bool canUpDateSwing = true; //Swing can be updated?
bool canUpDateDetune = true; //Swing can be updated?

//mixer mode - to adjust volume and probability
float masterVolume = 0.4;
float volumeKnobPosition, probabilityKnobPosition, swingKnobPosition, detuneKnobPosition;//Used to retain current pot position so it can be compared to new values read from pots.
bool canUpDateBPM = true; //BPM can be updated
bool upDateVolumeProbability = false; //OK to update these
int currentSoundIndex = 0;//count through Sounds 0 = Master Volume & Probability
const char accInstrumentNames[10][6] = {"Mast", "aKick", "aSnar", "aClHH", "aOpHH", "aCrsh", "aRide", "Synt", "Uni", "Sub"}; //For display
const char elecInstrumentNames[10][6] = {"Mast", "eKick", "eSnar", "eClHH", "eOpHH", "eLTom", "eHTom", "Synt", "Uni", "Sub"};
//Volumes Match list above Kick, Snare etc...
bool canUpDateVolume[10] = {false, false, false, false, false, false, false, false, false, false}; //Should the Volume for each sound be updated.
bool canUpDateProbability[10] = {false, false, false, false, false, false, false, false, false, false}; //Should the Probability for each sound be updated
float instrumentProbability [10] = {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0};
float instrumentVolume [10] = {1.0, 1.0, 1.0, 1.0, 0.6, 0.6, 1.0, 1.0, 1.0, 1.0};

// ********************

// ==== General ===================================================================== General
//modes
byte pedalMode = 3;
// ********************
#define numModes  4
const char pedalModeNames[numModes][4] = {"Syn", "Lat", "Arp", "S"};// Char array number of strings then size of each string
// ********************!
int t1, t2; //Times to make sure the BPM delay is consistent.

// ===== Hardware =================================================================== Hardware

// ---- Analogue -------------------------------------------------------------------- Analogue
int potPin [6] = {A0, A8, A14, A15, A16, A17};   // Input pins from the 4 potentiometers and from 16 and 17 the expression pedals
int potVals [6]; //input values from pots

// ---- Switches -------------------------------------------------------------------- Switches
#define numberSwitches 15

//define switch names
#define foot1 0
#define foot2 1
#define foot3 2
#define foot4 3
#define foot5 4
#define foot6 5
#define foot7 35  //should be 30 to match Video 2. I had an issue with a wire snapping off. Pin 30 was awkward to get to
#define foot8 31
#define foot9 32
#define foot10 33
#define footUp 36
#define footDown 37
#define button1 26
#define button2 27
#define button3 34
#define modeSwitch 8
#define enterSwitch 9
#define downSwitch 10
#define upSwitch 11
#define b1Switch 12
#define b2Switch 13
#define b3Switch 14

//Storage for Buttons/Foot Pedals
const int switchPins[numberSwitches] = {foot1,  foot2, foot3, foot4, foot5, foot6, foot7, foot8, foot9, foot10, footUp, footDown, button1, button2, button3}; // Note that the last five positions represent footUp, footDown and the three additional switches respectively
int previousSwitchValues [numberSwitches]; //used to avoid retriggering synth during looping - Not using bounce library due to varying length of waitTimes and due to it being a footpedal (secondary instrument)
int switchValues [numberSwitches];

//--- Oled Screen ------------------------------------------------------------------- Oled Screen
#include <Adafruit_SSD1306.h>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
#define OLED_RESET     4 // Reset pin # 
#define SCREEN_ADDRESS 0x3C // Found using scanner

//Initialize OLED screen. Changed Wire to Wire2 for SCL2 and SDA2
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire2, OLED_RESET);

// === MIDI and Music ========================================================================= MIDI and Music
//Using MIDI Note numbers
//#include <MIDI.h>
//MIDI_CREATE_INSTANCE(HardwareSerial, Serial7, MIDI); //to send MIDI out
//int channel = 1;
//byte midi_clock = 0xf8;//sent 3 times per 8th note
////byte startMIDI = 0xfa;
//byte stopMIDI = 0xfc; //MIDI stop

//Music Stuff
byte BPM = 250;//Beats per Minute, I make the maximum 250 later
int waitTime = 40; //Time between sending MIDI clock bytes
int spareTime = 40; //Time left after processes are done that needs to be padded/wasted while waiting for mext beat/note

int rootNote = 36, lowestNote = 24, highestNote = 80;
//Map 128 MIDI notes to actual frequencies for A = 440Hz
const float noteFreqs[128] = {8.176, 8.662, 9.177, 9.723, 10.301, 10.913, 11.562, 12.25, 12.978, 13.75, 14.568, 15.434, 16.352, 17.324, 18.354, 19.445, 20.602, 21.827, 23.125, 24.5, 25.957, 27.5, 29.135, 30.868, 32.703, 34.648, 36.708, 38.891, 41.203, 43.654, 46.249, 48.999, 51.913, 55, 58.27, 61.735, 65.406, 69.296, 73.416, 77.782, 82.407, 87.307, 92.499, 97.999, 103.826, 110, 116.541, 123.471, 130.813, 138.591, 146.832, 155.563, 164.814, 174.614, 184.997, 195.998, 207.652, 220, 233.082, 246.942, 261.626, 277.183, 293.665, 311.127, 329.628, 349.228, 369.994, 391.995, 415.305, 440, 466.164, 493.883, 523.251, 554.365, 587.33, 622.254, 659.255, 698.456, 739.989, 783.991, 830.609, 880, 932.328, 987.767, 1046.502, 1108.731, 1174.659, 1244.508, 1318.51, 1396.913, 1479.978, 1567.982, 1661.219, 1760, 1864.655, 1975.533, 2093.005, 2217.461, 2349.318, 2489.016, 2637.02, 2793.826, 2959.955, 3135.963, 3322.438, 3520, 3729.31, 3951.066, 4186.009, 4434.922, 4698.636, 4978.032, 5274.041, 5587.652, 5919.911, 6271.927, 6644.875, 7040, 7458.62, 7902.133, 8372.018, 8869.844, 9397.273, 9956.063, 10548.08, 11175.3, 11839.82, 12543.85};
float detune = 1.000;
//Scale Intervals
const byte majorScale[15]         = {0, 2, 4, 5, 7, 9, 11, 12, 14, 16, 17, 19, 21, 23, 24}; //e.g. D, E, F#,G, A, B, C#, D.  Two Octaves for Arpegiator
const byte harmonicMinorScale[15] = {0, 2, 3, 5, 7, 8, 11, 12, 14, 15, 17, 19, 20, 23, 24}; //e.g. D, E, F, G, A, Bâ™­, C, D.
bool playMajorScale = false;
const char keys [12][3] = {"C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"};//display current key. Display doesn't like the flat symbol 3 Chars needed for each element for null?
char displayChar [4]; //To display the current key to the screen

//Arpegiator
int arpRootNote = 36;
int arpLength = 4;
int currentArpNote = 0;
int currentArpPattern = 0;
const byte numberArpPatterns = 8;
byte arpNotes [8] = {0, 2, 4, 2, 4, 6, 7, 4};
const byte arpPatterns[numberArpPatterns][8] = { {0, 2, 4, 7, 0, 2, 4, 6}, {7, 6, 4, 2, 0, 2, 4, 2}, {0, 2, 0, 4, 0, 6, 0, 7}, {0, 7, 0, 6, 0, 4, 0, 2}, {0, 2, 4, 2, 4, 0, 2, 4}, {0, 2, 4, 2, 4, 6, 7, 4}, {2, 4, 0, 2, 4, 7, 0, 4}, {2, 4, 0, 2, 4, 6, 7, 4}};

//Song Patterns
#define tieNote 100
#define restNote 110
#define endPattern 200
//char songPatternName [5] = {"TV1"};
int songRootNote = 36; //not really used much
int currentsongNote = 0;
int songEditNote = 0; //note being editted
bool songEditMode = false;  //Editing?
int currentSongBank = 0;
int currentSongPattern = 0;
// Pattern being played now
byte songPattern [32] = {0, 110, 0, 3, tieNote, tieNote, 0, restNote, 0, 7, 6, 5, 0, restNote, 0, 3, tieNote, tieNote, 0, restNote, 0, 7, 6, 5, endPattern, 0, 6, 0, 7, 0, 4, 0};
// Pattern queued to play next
byte songNextPattern [32] = {0, 110, 0, 3, tieNote, tieNote, 0, restNote, 0, 7, 6, 5, 0, restNote, 0, 3, tieNote, tieNote, 0, restNote, 0, 7, 6, 5, endPattern, 0, 6, 0, 7, 0, 4, 0};
// "Note values" for song mode
const byte songValues [27] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, tieNote, restNote, endPattern };
// Display values for songValues
int songValuesIndex = 0;
const char songKeys [27][4] = { "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B", "c", "c#", "d", "d#", "e", "f", "f#", "g", "g#", "a", "a#", "b" , "_", "", "X"};

int tickCounter = 0;// To count MIDI clock ticks so Beats can be placed. 3 ticks to the 8th Note

// ==== SetUp ======================================================================= SetUp
void setup() {
  //USB Serial for debugging
  Serial.begin(9600);                     //Serial Monitor
  //MIDI Serial in and out
  //  Serial7.begin(31250);                   //MIDI baud rate
  //  Serial7.write(stopMIDI);                // just in case
  //  MIDI.begin(MIDI_CHANNEL_OMNI);          // Launch MIDI and listen

  //--- Switches --------------------------------------------
  for (int i = 0; i < numberSwitches; i++) {
    pinMode(switchPins[i], INPUT_PULLUP);
  }

  //--- Screen ------------------------------------------------
  //   SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;); // Don't proceed, loop forever
  }

  //--- Audio -----------------------------------------------
  AudioMemory(10);// 10 is more than enough for the mono synth and one lot of drums
  sgtl5000_1.enable();                    //Using Line Out so don't need to set volume for this
  waveformMain.begin(WAVEFORM_SAWTOOTH);     //Choosing this waveform. There are many others.
  ladderMain.octaveControl(2.6);             // up 2.6 octaves (4850 Hz) & down 2.6 octaves (132 Hz)

  //**********************************
  waveformSub.begin(WAVEFORM_TRIANGLE);     //Choosing this waveform for sub note
  waveformUnison.begin(WAVEFORM_SAWTOOTH);     //Choosing this waveform. There are many others.
  //**********************************

  for (int i = 0; i < 10; i++) previousSwitchValues[i] = HIGH; //indicate not previously pressed

  //**********************************
  setinstrumentVolumes(masterVolume);
  //----- Probability seed - Generate Random Numbers
  randomSeed(analogRead(10)); //using a floating pin on back of Teensy - not connected
  //**********************************

}

// === Loop ========================================================================= Loop

void loop() {
  t1 = millis(); //start time for consistent delay
  readSwitches();
  readPots();
  showScreen();
  adjustSwing();
  //playing arp mode?
  if (pedalMode == 2 && tickCounter % 3 == 0) playArpNote(); //playing 8th Notes
  //playing song mode?
  // **********************************
  if (pedalMode == 3) {
    if (tickCounter % 3 == 0) {// 3 MIDI clock ticks have passed
      if (drumsOn) {
        setDrums();//change change pattern midway through bar for interesting combinations
        playsongNote(); //playing 8th Notes
        playbeats();
      } else {
        envelopeMain.noteOff();
        envelopeUnison.noteOff();
        envelopeSub.noteOff();
      }
    }
  }
  // **********************************

  int t2 = millis(); //To enable the calculation of how long have the previous tasks taken
  // *******************************
  spareTime = waitTime * swingAdjustment - (t2 - t1); //How much slack time is there
  //  s("swing:", swing);
  //  s("swingAdjustmenting: ", swingAdjustment);
  //  s("spareTime: ", spareTime);
  while (t2 - t1 < waitTime * swingAdjustment) { //While waiting check MIDI in and Expression pedals
    // ****************************************
    //checkMIDIin();
    checkExpressionPedals(); //checking inside this loop to improve the smoothness of filter sweeps
    t2 = millis();
  }
  //After waiting the right amount send MIDI clock
  //  Serial7.write(midi_clock);
  tickCounter++;
  //end of bar?
  if (tickCounter >= 24) {
    tickCounter = 0;
  }
}

// === Play Notes =========================================================================== Play Notes
// ***********************

void adjustSwing() {
  if (pedalMode != 3) {//Swing only in Song Mode
    swingAdjustment = 1.0;
    return;
  }
  //swing = 1.4;
  if (tickCounter % 3 == 0) {
    if (tickCounter % 2 == 0) swingAdjustment = swing;
    else swingAdjustment = 1 / swing;
  }
}

void playbeats() {
  //Play beats either Acoustic or electronic kit.
  if (acousticDrums) {
    if (kickSequence[beatNum] == 'x' && random(100) <= 100 * instrumentProbability[1] ) playMemKick.play(Acoustickick);
    if (snareSequence[beatNum] == 'x' && random(100) <= 100 * instrumentProbability[2]) playMemSnare.play(AcousticSnare);
    if (hiHatSequence[beatNum] == 'x' && random(100) <= 100 * instrumentProbability[3]) playMemCHh.play(AcousticClosedhihat);
    if (openHiHatSequence[beatNum] == 'x' && random(100) <= 100 * instrumentProbability[4]) playMemOHh.play(AcousticOpenhihat);
    if (crashSequence[beatNum] == 'x' && random(100) <= 100 * instrumentProbability[5]) playMemCrash.play(AcousticCrashcymbal);
    if (rideSequence[beatNum] == 'x' && random(100) <= 100 * instrumentProbability[6]) playMemRide.play(Acousticridecymbal);
  } else {
    if (kickSequence[beatNum] == 'x' && random(100) <= 100 * instrumentProbability[1]) playMemKick.play(e606Kick);
    if (snareSequence[beatNum] == 'x' && random(100) <= 100 * instrumentProbability[2]) playMemSnare.play(e606Snare);
    if (hiHatSequence[beatNum] == 'x' && random(100) <= 100 * instrumentProbability[3]) playMemCHh.play(e606Closedhihat);
    if (openHiHatSequence[beatNum] == 'x' && random(100) <= 100 * instrumentProbability[4]) playMemOHh.play(e606Openhihat);
    if (crashSequence[beatNum] == 'x' && random(100) <= 100 * instrumentProbability[5]) playMemCrash.play(e606Lowtom);
    if (rideSequence[beatNum] == 'x' && random(100) <= 100 * instrumentProbability[6]) playMemRide.play(e606Hightom);
  }

  //choke Open HiHat if closed Hi Hat is played
  if (hiHatSequence[beatNum] == 'x') {
    if (playMemOHh.isPlaying() ) playMemOHh.stop();
  }

  beatNum++;
  if (beatNum >= barLength[beatType]) beatNum = 0;
}
// **********************

//Normal playing of a note in Synth and Latch Mode
void initiateNote(int i) {
  AudioNoInterrupts(); //Disable the audio library update interrupt. This allows more than 1 object's settings to be changed simultaneously.
  if (playMajorScale) {
    waveformMain.frequency(noteFreqs[rootNote + majorScale[i]]);
    waveformUnison.frequency(noteFreqs[rootNote + majorScale[i]] * detune);
    waveformSub.frequency((noteFreqs[rootNote + majorScale[i]]) / 2);
  }
  else {
    waveformMain.frequency(noteFreqs[rootNote + harmonicMinorScale[i]]);
    waveformUnison.frequency(noteFreqs[rootNote + harmonicMinorScale[i]]* detune);
    waveformSub.frequency((noteFreqs[rootNote + harmonicMinorScale[i]]) / 2);
  }
  envelopeMain.noteOn();
  envelopeUnison.noteOn();
  envelopeSub.noteOn();
  AudioInterrupts();
}

//Playing a note in Arp Mode
void playArpNote() {
  AudioNoInterrupts();
  envelopeMain.noteOff();
  envelopeUnison.noteOff();
  envelopeSub.noteOff();
  if (playMajorScale) {
    waveformMain.frequency(noteFreqs[arpRootNote + majorScale[arpNotes [currentArpNote]]]);
    waveformUnison.frequency(noteFreqs[arpRootNote + majorScale[arpNotes [currentArpNote]]]*detune);
    waveformSub.frequency((noteFreqs[arpRootNote + majorScale[arpNotes [currentArpNote]]]) / 2);
  }
  else {
    waveformMain.frequency(noteFreqs[arpRootNote + harmonicMinorScale[arpNotes [currentArpNote]]]);
    waveformUnison.frequency(noteFreqs[arpRootNote + harmonicMinorScale[arpNotes [currentArpNote]]]*detune);
    waveformSub.frequency((noteFreqs[arpRootNote + harmonicMinorScale[arpNotes [currentArpNote]]]) / 2);
  }
  envelopeMain.noteOn();
  envelopeUnison.noteOn();
  envelopeSub.noteOn();
  AudioInterrupts();
  currentArpNote++;
  if (currentArpNote >= arpLength) currentArpNote = 0;
}

//Playing a note in song mode
void playsongNote() {
  AudioNoInterrupts();
  if (songPattern[currentsongNote] != tieNote) { //if a tienote keep playing current note
    envelopeMain.noteOff();
    envelopeUnison.noteOff();
    envelopeSub.noteOff();
    if (songPattern[currentsongNote] < 100 ) {//only set frequency to proper notes
      waveformMain.frequency(noteFreqs[songRootNote + songPattern [currentsongNote]]);
      waveformUnison.frequency(noteFreqs[songRootNote + songPattern [currentsongNote]]*detune);
      waveformSub.frequency((noteFreqs[songRootNote + songPattern [currentsongNote]]) / 2);
    }
    if (songPattern[currentsongNote] != restNote ) {
      if (random(100) <= 100 * instrumentProbability[7] ) envelopeMain.noteOn(); //play if not a rest
      if (random(100) <= 100 * instrumentProbability[8] ) envelopeUnison.noteOn(); //play if not a rest
      if (random(100) <= 100 * instrumentProbability[9] ) envelopeSub.noteOn();
    }
  }
  AudioInterrupts();
  currentsongNote++;
  if (songPattern[currentsongNote] == endPattern || currentsongNote > 31) {
    currentsongNote = 0;
    loadNextPattern();
  }
}

// === Hardware =========================================================================== Hardware

bool switchJustPressed(int i) {
  if (previousSwitchValues[i] == HIGH && switchValues[i] == LOW) return true;           //newly pressed
  return false;
}

bool switchJustReleased(int i) {
  if (previousSwitchValues[i] == LOW && switchValues[i] == HIGH) return true; //Just Released
  return false;
}

void readSwitches() {
  //Check the Switches that play a note or choose a pattern in song mode ----------------------
  int lastPattern = currentSongPattern;
  for (int i = 0; i < 8; i++) {
    switchValues[i] = digitalRead(switchPins[i]);

    //Switch pressed?
    if (switchJustPressed(i)) {
      //arp mode. Set chord root
      if (pedalMode == 0) initiateNote(i);
      if (pedalMode == 1) {
        envelopeMain.noteOff();//latch mode and arp mode
        envelopeUnison.noteOff();//latch mode and arp mode
        envelopeSub.noteOff();
        initiateNote(i);
      }
      if (pedalMode == 2) arpRootNote = rootNote + i;
      //Song and Song Edit Modes

      //Using pedals 1 to 5 to select a pattern within a song
      if (pedalMode == 3) {
        if (i < 5) currentSongPattern = currentSongBank * 5 + i;

        // ********************
        if (i == 5) {
          if (!drumsOn && countIn)  doTheCountIn();
          drumsOn = !drumsOn;
          beatNum = 0;
          currentsongNote = 0;
          loadNextPattern();
        }
        //Change Drum Pattern
        if (i == 6) {
          complexity--;
          if (complexity < 0) complexity = 0;
        }
        if (i == 7) {
          complexity++;
          if (complexity > 11) complexity = 11;
        }
        preLoadSongFromEEProm(currentSongPattern);
      }
      // ********************!

      previousSwitchValues[i] = LOW;
    }

    //Switch released?
    if (switchJustReleased(i)) {
      if (pedalMode == 0) {
        envelopeMain.noteOff();//not latch mode, so turn off note on release
        envelopeUnison.noteOff();//not latch mode, so turn off note on release
        envelopeSub.noteOff();
      }
      previousSwitchValues[i] = HIGH;
    }
  } //End of Play a note or Pattern

  //check the other switches ------------------------------
  for (int i = 8; i < numberSwitches; i++) {
    switchValues[i] = digitalRead(switchPins[i]);

    //Switch pressed?
    if (switchJustPressed(i)) {
      //Change Mode
      if (i == modeSwitch) {
        pedalMode++;
        if (pedalMode >= numModes) pedalMode = 0;
        envelopeMain.noteOff(); //Turn off note if changing mode to avoid lingering notes
        envelopeUnison.noteOff(); //Turn off note if changing mode to avoid lingering notes
        envelopeSub.noteOff();
      }
      if (i == enterSwitch && pedalMode == 1) {
        envelopeMain.noteOff();// latch mode - turn off note
        envelopeUnison.noteOff();// latch mode - turn off note
        envelopeSub.noteOff();
      }
      //Up and Down change octave if Synth or Latched Synth chosen
      // 111111111111111111111111111
      if (pedalMode <= 1) {
        if (i == downSwitch) {
          rootNote = rootNote - 12;
          if (rootNote < lowestNote) rootNote = lowestNote;
        }
        //up
        if (i == upSwitch) {
          rootNote = rootNote + 12;
          if (rootNote > highestNote) rootNote = highestNote;
        }
      }
      // 2222222222222222222222222
      //Up and Down change arpegio if arp mode
      if (pedalMode == 2) {
        if (i == downSwitch) {
          arpLength--;
          if (arpLength < 2) arpLength = 2;
        }
        //up
        if (i == upSwitch) {
          arpLength++;
          if (arpLength > 8) arpLength = 8;
        }
        if (i == enterSwitch) { //Change Arp Pattern
          currentArpPattern++;
          if (currentArpPattern >= numberArpPatterns) currentArpPattern = 0;
          for (int i = 0; i < 8; i++) {
            arpNotes[i] = arpPatterns[currentArpPattern][i];
          }
        }
      }
      // 333333333333333333333333
      //Change to editmode and save changes in Song Mode
      if (pedalMode == 3) {
        if (i == enterSwitch) {
          if (songEditMode) saveNewNote(currentSongPattern);
          songEditMode = !songEditMode;
        }
        //Have up or down pedals been pushed?
        checkSongModeBankSwitching(i);
      }
      //****************************
      // 3 Momentary Switches
      // !3!3!3!3!3!3!3!3!3!3!3!3!3!3!3!3
      if (pedalMode != 3) {
        if (i == b1Switch) playMajorScale = !playMajorScale;
        if (i == b2Switch) {
          rootNote--;
          if (rootNote < lowestNote) rootNote = lowestNote;
        }
        if (i == b3Switch) {
          rootNote++;
          if (rootNote > highestNote) rootNote = highestNote;
        }
        //Song Mode means different modes for these momentary buttons
      } else {
        if (i == b1Switch) {
          beatType++;
          if (beatType > 4) beatType = 0;
        }
        //Change to Mixer mode and go through each sound
        if (i == b2Switch) {
          if ( switchValues[13] == LOW) {
            canUpDateBPM = true;
            for (int i = 0; i < 10; i++) {
              canUpDateVolume[i] = false;
              canUpDateProbability[i] = false;
            }
            canUpDateSwing = false;
            canUpDateDetune = false;
            currentSoundIndex++;
            if (currentSoundIndex >= 10) currentSoundIndex = 0;
          }
        }
        //Toggle count in when in song mode but not mixer mode
        if (i == b3Switch && currentSoundIndex == 0) countIn = !countIn;
        //Escape Mixer Mode in when in mixer mode
        if (i == b3Switch && currentSoundIndex > 0) currentSoundIndex = 0;
      }
      //************************
      previousSwitchValues[i] = LOW;
    }

    //Switch released?
    if (switchJustReleased(i)) {
      previousSwitchValues[i] = HIGH;
    }
  }
  // *************************
  //easter eggs
  if (pedalMode == 3 && switchValues[0] == LOW && switchValues[1] == LOW && !drumsOn)  {
    someoneToldAJoke();
    currentSongPattern = lastPattern;
  }
  if (pedalMode == 3 && switchValues[3] == LOW && switchValues[4] == LOW && !drumsOn)  {
    playBigEnding();
    currentSongPattern = lastPattern;
  }
  // **************************
}

// **********************
//=== easter eggs ================================================================
void someoneToldAJoke() {
  display.clearDisplay();
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE); // Draw white text
  display.setCursor(0, 20);
  display.println("badum tish");
  display.display();
  //Boom Tish
  playMemKick.play(Acoustickick);
  delay(100);
  playMemSnare.play(AcousticSnare);
  delay(200);
  playMemCrash.play(AcousticCrashcymbal);
  delay(3000);
}

void playBigEnding() {
  display.clearDisplay();
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE); // Draw white text
  display.setCursor(0, 20);
  display.println("BIG finish");
  display.display();
  int waitTime = 750;
  playMemKick.play(Acoustickick);
  delay(waitTime / 3);
  playMemKick.play(Acoustickick);
  delay(waitTime / 3);
  playMemSnare.play(AcousticSnare);
  delay(waitTime / 3);
  playMemKick.play(Acoustickick);
  delay(waitTime / 3);
  playMemKick.play(Acoustickick);
  delay(waitTime / 3);
  playMemSnare.play(AcousticSnare);
  delay(waitTime);

  playMemKick.play(Acoustickick);
  playMemSnare.play(AcousticSnare);
  playMemOHh.play(AcousticOpenhihat);
  delay(waitTime);

  playMemSnare.play(AcousticSnare);
  playMemOHh.play(AcousticOpenhihat);
  delay(waitTime);

  playMemKick.play(Acoustickick);
  playMemSnare.play(AcousticSnare);
  playMemCrash.play(AcousticCrashcymbal);
  delay(waitTime * 2);
}

void doTheCountIn() {
  delay(waitTime * 24);
  playMemCHh.play(AcousticClosedhihat);
  delay(waitTime * 12);
  playMemCHh.play(AcousticClosedhihat);
  delay(waitTime * 12);
  playMemCHh.play(AcousticClosedhihat);
  delay(waitTime * 6);
  playMemCHh.play(AcousticClosedhihat);
  delay(waitTime * 6);
  playMemCHh.play(AcousticClosedhihat);
  delay(waitTime * 6);
  playMemCHh.play(AcousticClosedhihat);
  delay(waitTime * 6);
  tickCounter = 0; //Make sure count in beat is aligned with loop timer
}

// *****************************

void checkSongModeBankSwitching(int i) {
  if (i == upSwitch) {
    currentSongBank++;
    if (currentSongBank > 19) currentSongBank = 0;
    currentSongPattern = currentSongBank * 5;
    preLoadSongFromEEProm(currentSongPattern);
  }
  if (i == downSwitch) {
    currentSongBank--;
    if (currentSongBank < 0) currentSongBank = 19;
    currentSongPattern = currentSongBank * 5;
    preLoadSongFromEEProm(currentSongPattern);
  }
}

void readPots() {
  //*******
  //Used to check if values can be updated
  float valueVol, valueProb, valueKit, valueSwing, valueDetune;
  //********
  for (int i = 0; i < 4; i++) {
    potVals[i] = analogRead(potPin[i]);
  }
  BPM = map( potVals[0] , 0, 1023, 20, 250); //sets maximum to 250
  waitTime = int(60000 / BPM / 6); //Time between MIDI clock out

  // ***********************************
  //check master volume when not in mixer mode
  if (currentSoundIndex == 0) {
    valueVol = 2 * float((potVals[1] - 40)) / 1023;
    volumeKnobPosition = valueVol;
    if (valueVol < 0.0) valueVol = 0.0;
    //Pickup - Only changes if value gets to current value
    if (valueVol >= masterVolume - 0.05 && valueVol <= masterVolume + 0.05) {
      canUpDateVolume[0] = true;
    }
    if (canUpDateVolume[0]) {
      masterVolume = valueVol;
    }
    waveformMain.amplitude(masterVolume);
    waveformUnison.amplitude(masterVolume);
    waveformSub.amplitude(masterVolume);
  }
  if (pedalMode == 3 && currentSoundIndex == 0) {
    //Alter Swing?
    valueSwing = float((potVals[2])) / 1023 + 0.5;
    swingKnobPosition = valueSwing;
    //Pickup - Only changes if value gets to current value
    if (valueSwing >= swing - 0.05 && valueSwing <= swing + 0.05) {
      canUpDateSwing = true;
    }
    if (canUpDateSwing) {
      swing = valueSwing;
    }
    //Alter detune?
    valueDetune = 1.0 + float((potVals[3])) / 50000;
    detuneKnobPosition = valueDetune;
    //Pickup - Only changes if value gets to current value
    if (valueDetune >= detune - 0.005 && valueDetune <= detune + 0.005) {
      canUpDateDetune = true;
    }
    if (canUpDateDetune) {
      detune = valueDetune;
    }
  }

  // ***********************************

  // ***********************************
  //In edit mode the 3rd and 4th pot choose and alter the note
  if (pedalMode == 3) {
    //Editing Song
    if (songEditMode) {
      //Which Note?
      songEditNote = map(potVals[2], 40, 1000, 0, 31);
      if (songEditNote > 31) songEditNote = 31;
      if (songEditNote < 0) songEditNote = 0;
      //What value?
      songValuesIndex = map(potVals[3], 40, 1000, 0, 26);
      if (songValuesIndex > 26) songValuesIndex = 26;
      if (songValuesIndex < 0) songValuesIndex = 0;
    } else {
      //Mixer Mode
      //calculate volume from knob
      valueVol =  2 * float((potVals[1] - 40)) / 1023;
      volumeKnobPosition = valueVol;
      if (valueVol < 0.0) valueVol = 0.0;
      //Pickup - Only changes if value gets to current value
      if (valueVol >= instrumentVolume[currentSoundIndex] - 0.05 && valueVol <= instrumentVolume[currentSoundIndex] + 0.05) {
        canUpDateVolume[currentSoundIndex] = true;
      }
      if (canUpDateVolume[currentSoundIndex]) {
        instrumentVolume[currentSoundIndex] = valueVol;
      }
      //calculate Probability from Knob
      valueProb =  float((potVals[2] - 40)) / 900;
      probabilityKnobPosition = valueProb;
      if (valueProb > 1.00) valueProb = 1.00;
      if (valueProb < 0.0) valueProb = 0.0;
      if (valueProb >= instrumentProbability[currentSoundIndex] - 0.05 && valueProb <= instrumentProbability[currentSoundIndex] + 0.05) {
        canUpDateProbability[currentSoundIndex] = true;
      }
      if (canUpDateProbability[currentSoundIndex]) {
        instrumentProbability[currentSoundIndex] = valueProb;
      }
      valueKit = float((potVals[3] - 40)) / 1023;
      if (valueKit < 0.5) acousticDrums = true;
      else acousticDrums = false;
    }
    setinstrumentVolumes(masterVolume);
    // ***********************************
  }
  checkExpressionPedals();
}

//need to check these more often due to waittime. Otherwise we get a more stepped change in sound when sweeping frequencies
void checkExpressionPedals() {
  //read expression pedals
  potVals[4] = analogRead(potPin[4]);
  potVals[5] = analogRead(potPin[5]);
  float res = float((potVals[4] - 40)) / 1000;//needs to be 0 to 1 in value
  ladderMain.resonance(res);
  ladderMain.frequency(potVals[5] * 3);
  ladderUnison.resonance(res);
  ladderUnison.frequency(potVals[5] * 3);
}

// === Song Mode Functions ========================================================================= Song Mode Functions

//Each Pattern is allocated 40 bytes - 32 for notes - others below maybe
void preLoadSongFromEEProm(int patternNumber) {
  int patternStart = patternNumber * 40;
  //This stuff is for possible future use
  //for (int i = 0; i < 5; i++) userPatternName[i] = EEPROM.read(patternStart + i);
  // userPatternTempo = EEPROM.read(patternStart + 5 );
  // userPatternRoot = EEPROM.read(patternStart + 6);
  // userPatternKeyType = EEPROM.read(patternStart + 7);
  for (int i = 0; i < 32; i++) songNextPattern[i] = EEPROM.read(patternStart + i + 8);
}

//As a note is changed it is saved to the song pattern and to the EEprom Storage
void saveNewNote(int patternNumber) {
  int patternStart = patternNumber * 40;
  songNextPattern[songEditNote] = songValues[songValuesIndex];  //update note on queued pattern
  songPattern[songEditNote] = songNextPattern[songEditNote];  //update current pattern
  EEPROM.write(patternStart + songEditNote + 8, songPattern[songEditNote]);
}

//Start the next bar with the queued pattern
void  loadNextPattern() {
  for (int i = 0; i < 32; i++) {
    songPattern[i] = songNextPattern[i];
  }
}

// === Screen =========================================================================== Screen

void showScreen() {
  display.clearDisplay();
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE); // Draw white text

  //song Mode
  if (pedalMode == 3) {
    // **********************
    if (currentSoundIndex > 0) showMixerInsteadOfNormalSongScreen();
    else { //Normal Song Mode Screen
      showModeAndBPM();
      showMasterVolumeBars();
      showSongModeScreen();
      // ******************
    }
    return; //Don't want to display the rest when in song mode
  }
  // ***********
  //Pedal Mode not 3 - from here on down
  showModeAndBPM();
  showMasterVolumeBars();
  // ********


  //Key
  display.setCursor(90, 0);
  strcpy(displayChar, keys[(rootNote - lowestNote) % 12]);
  if (!playMajorScale) strcat(displayChar, "m");
  display.println(displayChar);

  //Octave
  display.setCursor(90, 20);
  display.println(rootNote);

  //Arp Length
  if (pedalMode == 2) {
    display.setCursor(0, 20);
    display.println(arpLength);
    display.setCursor(20, 20);
    display.println(currentArpPattern);
  }

  //Show pedal use by mode. Help.
  if (pedalMode == 1) {       //Normal Synth Mode
    display.setTextSize(1);
    display.setCursor(0, 40);
    display.println("Enter: Stop Note");
  }
  if (pedalMode <= 1) {       //latch mode
    display.setTextSize(1);
    display.setCursor(0, 50);
    display.println("Up/Dn: Octave");
  }
  if (pedalMode == 2) {       //arp mode
    display.setTextSize(1);
    display.setCursor(0, 50);
    display.println("Up/Dn: Pattern Length");
    display.setTextSize(1);
    display.setCursor(0, 40);
    display.println("Enter: Change Pattern");
  }

  //---- diagnostic stuff that doesn't need to be there.
  int iMem = AudioMemoryUsageMax();
  display.setCursor(45, 25);
  display.println(iMem);
  display.setTextSize(1);
  display.setCursor(65, 25);
  display.println(spareTime);
  // ----

  display.display();
}

void showSongModeScreen() {
  bool foundX = false;
  // ******************
  display.setTextSize(1);
  display.setCursor(20, 0);
  display.print(complexity);
  display.setCursor(20, 10);
  display.print(beatString[beatType]);
  if (countIn) {
    display.setCursor(12, 0);
    display.print("#");
  }

  // ******************
  display.setTextSize(2);
  display.setCursor(85, 0);
  display.println(currentSongBank + 1);
  display.setCursor(110, 0);
  display.println(currentSongPattern % 5 + 1);//show pattern number that matches pedal numbers
  display.setTextSize(1);
  int x, y;
  for (int i = 0; i < 32; i++) {
    x = i % 8;
    y = int(i / 8);
    display.setCursor(x * 16, y * 10 + 20);
    if (!foundX) {
      if (!songEditMode && currentsongNote == i) display.fillCircle(x * 16 + 3, y * 10 + 20 + 3, 6, SSD1306_WHITE);
      if (songEditMode && songEditNote == i) display.fillCircle(x * 16 + 3, y * 10 + 20 + 3, 6, SSD1306_WHITE);
      display.setTextColor(SSD1306_WHITE);
      if (!songEditMode && currentsongNote == i) display.setTextColor(SSD1306_BLACK);
      if (songEditMode && songEditNote == i) display.setTextColor(SSD1306_BLACK);
      switch (songPattern[i]) {
        case tieNote:
          display.print("__");
          break;
        case restNote:
          // statements
          break;
        case endPattern:
          display.print("X");
          if (!songEditMode) foundX = true;
          break;
        default:
          if (songPattern[i] < 27) display.print(songKeys[songPattern[i]]);
          break;
      }
    } else {
      display.print("."); //Note positions after endPattern "X"
    }
  }
  display.display();
}

// **********************

void showModeAndBPM() {
  display.setCursor(0, 0);
  //Display mode
  if (!songEditMode) display.println(pedalModeNames [pedalMode]); //What mode is current
  else display.println("E");
  //BPM
  display.setCursor(45, 0);
  if (!songEditMode) display.println(BPM);
  else display.println(songKeys[songValuesIndex]);

}

void showMasterVolumeBars() {
  //******************
  //Show Master Volume
  display.drawLine(0, 61, int(30 * masterVolume), 61, SSD1306_WHITE);
  //Show Knob Position
  display.drawLine(0, 63, int(30 * volumeKnobPosition), 63, SSD1306_WHITE);
  //Show Master Swing
  display.drawLine(90, 61, int(30 * swing) + 60, 61, SSD1306_WHITE);
  //Show Knob Position
  display.drawLine(90, 63, int(30 * swingKnobPosition) + 60, 63, SSD1306_WHITE);

  // ********
}

void showMixerInsteadOfNormalSongScreen() {
  //Just the stuff needed when in Mixer Mode.
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE); // Draw white text
  display.setCursor(0, 0);
  display.println("Mix");
  display.setCursor(55, 0);
  if (acousticDrums) display.println(accInstrumentNames[currentSoundIndex]);
  else  display.println(elecInstrumentNames[currentSoundIndex]);
  display.setCursor(0, 20);
  display.println("Vol");
  display.setCursor(0, 40);
  display.println("Prob");
  display.setCursor(70, 20);
  display.println(instrumentVolume[currentSoundIndex]);
  display.setCursor(70, 40);
  display.println(instrumentProbability[currentSoundIndex]);
  //Show Individual Volume
  display.drawLine(0, 57, int(60 * instrumentVolume[currentSoundIndex]), 57, SSD1306_WHITE);
  //Show Knob Position
  display.drawLine(0, 58, int(60 * volumeKnobPosition), 58, SSD1306_WHITE);
  //Show Probability
  display.drawLine(0, 62, int(60 * instrumentProbability[currentSoundIndex]), 62, SSD1306_WHITE);
  //Show Knob Position
  display.drawLine(0, 63, int(60 * probabilityKnobPosition), 63, SSD1306_WHITE);
  display.display();
}

// *************
//Drum Patterns
void setDrums() {
  if (beatType == 0) {
    switch (complexity) {
      // 3/4
      case 0:
        // statements
        strcpy(kickSequence,       "........................");
        strcpy(snareSequence,      "........................");
        strcpy(hiHatSequence,      "x.....x.....x.....x.....");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");

        break;
      case 1:
        // statements
        strcpy(kickSequence,       "........................");
        strcpy(snareSequence,      "........................");
        strcpy(hiHatSequence,      "x.x.x.x.x.x.x.x.x.x.x.x.");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "x.......................");
        break;
      case 2:
        // statements
        strcpy(kickSequence,       "x...........x...........");
        strcpy(snareSequence,      "........................");
        strcpy(hiHatSequence,      "x.x.x.x.x.x.x.x.x.x.x.x.");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "x.....................x.");
        break;
      case 3:
        // statements
        strcpy(kickSequence,       "x...........x...........");
        strcpy(snareSequence,      "..................x.....");
        strcpy(hiHatSequence,      "..x.x.x.x.x.x.x.x.x.x.x.");
        strcpy(openHiHatSequence,  "x.......................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 4:
        // statements
        strcpy(kickSequence,       "x...........x...........");
        strcpy(snareSequence,      "......x...........x.....");
        strcpy(hiHatSequence,      "..x.x.x.x.x.x.x.x.x.x.x.");
        strcpy(openHiHatSequence,  "x.......................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 5:
        // statements
        strcpy(kickSequence,       "x...........x...x.......");
        strcpy(snareSequence,      "......x...........x.....");
        strcpy(hiHatSequence,      "x.x.x.x.x.x.x.x.x.x.x.x.");
        strcpy(openHiHatSequence,  "x...........x...........");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 6:
        // statements
        strcpy(kickSequence,       "x...........x...x.......");
        strcpy(snareSequence,      "......x.x.........x.....");
        strcpy(hiHatSequence,      "x.x.x.x.x.x.x.x.x.x.x.x.");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 7:
        // statements
        strcpy(kickSequence,       "x...........x...x.......");
        strcpy(snareSequence,      "......x...........x.....");
        strcpy(hiHatSequence,      "x.x.x.x.x.x.x.x.x.x.x.x.");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 8:
        // statements
        strcpy(kickSequence,       "x...........x...x.......");
        strcpy(snareSequence,      "......x...........x.....");
        strcpy(hiHatSequence,      "..x.x.x.x.x.x.x.x.x.x.x.");
        strcpy(openHiHatSequence,  "x.......................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 9:
        // statements
        strcpy(kickSequence,       "x...........x...x.......");
        strcpy(snareSequence,      "......x...........x.....");
        strcpy(hiHatSequence,      ".xx.x.x.x.x..xx.x.x.x.x.");
        strcpy(openHiHatSequence,  "x...........x...........");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 10:
        // statements
        strcpy(kickSequence,       "x...........x...x.......");
        strcpy(snareSequence,      "......x...........x.....");
        strcpy(hiHatSequence,      "..x.x.x.x.x...x.x.x.x.x.");
        strcpy(openHiHatSequence,  "x...........x...........");
        strcpy(crashSequence,      "x.......................");
        strcpy(rideSequence,       "........................");
        break;
      case 11:
        // statements
        strcpy(kickSequence,       "x...........x...x.......");
        strcpy(snareSequence,      "......x...........x.....");
        strcpy(hiHatSequence,      ".xx.x..xx.x..xx.x..xx.x.");
        strcpy(openHiHatSequence,  "x.....x.....x.....x.....");
        strcpy(crashSequence,      "x...........x...........");
        strcpy(rideSequence,       "x.....x.....x.....x..x..");
        break;
      default:
        // statements
        break;
    }
  }
  // 4/4 beatType
  if (beatType == 1) {
    // 4/4 beatType Use 16
    switch (complexity) {
      case 0:
        // statements
        strcpy(kickSequence,       "........................");
        strcpy(snareSequence,      "........................");
        strcpy(hiHatSequence,      "x...x...x...x...........");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");

        break;
      case 1:
        // statements
        strcpy(kickSequence,       "x.......x...............");
        strcpy(snareSequence,      "........................");
        strcpy(hiHatSequence,      "x...x...x...x...........");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 2:
        // statements
        strcpy(kickSequence,       "x.......x...............");
        strcpy(snareSequence,      "....x.......x...........");
        strcpy(hiHatSequence,      "x...x...x...x...........");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 3:
        // statements
        strcpy(kickSequence,       "x.......x...............");
        strcpy(snareSequence,      "....x.......x...........");
        strcpy(hiHatSequence,      "x.x.x.x.x.x.x.x.........");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 4:
        // statements
        strcpy(kickSequence,       "x.......x.....x.........");
        strcpy(snareSequence,      "....x.......x...........");
        strcpy(hiHatSequence,      "x.x.x.x.x.x.x.x.........");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 5:
        // statements
        strcpy(kickSequence,       "x.......x...............");
        strcpy(snareSequence,      "....x......x..x.........");
        strcpy(hiHatSequence,      "x.x.x.x.x.x.x.x.........");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 6:
        // statements
        strcpy(kickSequence,       "x.......x...x...........");
        strcpy(snareSequence,      "....x.....x...x.........");
        strcpy(hiHatSequence,      "x.x.x.x.x.x.x.x.........");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 7:
        // statements
        strcpy(kickSequence,       "x.....x.x...............");
        strcpy(snareSequence,      "....x.......x.x.........");
        strcpy(hiHatSequence,      "x.x.x.x.x.x.x.x.........");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 8:
        // statements
        strcpy(kickSequence,       "x.....x.x...............");
        strcpy(snareSequence,      "....x.......x.x.........");
        strcpy(hiHatSequence,      "x.x.x.x.x.x.x.x.........");
        strcpy(openHiHatSequence,  "x.......................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 9:
        // statements
        strcpy(kickSequence,       "x.....x.x...............");
        strcpy(snareSequence,      "....x.......x.x.........");
        strcpy(hiHatSequence,      "x.x.x.x.x.x.x.x.........");
        strcpy(openHiHatSequence,  "x.......x...............");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 10:
        // statements
        strcpy(kickSequence,       "x.....x.x...............");
        strcpy(snareSequence,      "....x.......x.x.........");
        strcpy(hiHatSequence,      "x.x.x.x.x.x.x.x.........");
        strcpy(openHiHatSequence,  "x.......x...............");
        strcpy(crashSequence,      "x.......................");
        strcpy(rideSequence,       "........................");
        break;
      case 11:
        // statements
        strcpy(kickSequence,       "x...x...x...x.x.........");
        strcpy(snareSequence,      "..x...x...x...x.........");
        strcpy(hiHatSequence,      "x.x.x.x.x.x.x.x.........");
        strcpy(openHiHatSequence,  "x...x...x...x...........");
        strcpy(crashSequence,      "x.......x...............");
        strcpy(rideSequence,       "........................");
        break;
      default:
        // statements
        break;
    }
  }
  // 12/8 beatType.
  if (beatType == 2) {
    switch (complexity) {
      case 0:
        // statements
        strcpy(kickSequence,       "........................");
        strcpy(snareSequence,      "........................");
        strcpy(hiHatSequence,      "x..x..x..x..x..x..x..x..");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "x.......................");
        break;
      case 1:
        // statements
        strcpy(kickSequence,       "x...........x...........");
        strcpy(snareSequence,      "........................");
        strcpy(hiHatSequence,      "x..x..x..x..x..x..x..x..");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "x.......................");
        break;
      case 2:
        // statements
        strcpy(kickSequence,       "x...........x...........");
        strcpy(snareSequence,      "........................");
        strcpy(hiHatSequence,      "xxxxxxxxxxxxxxxxxxxxxxxx");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 3:
        // statements
        strcpy(kickSequence,       "x.....x.....x.....x.....");
        strcpy(snareSequence,      ".........x...........x..");
        strcpy(hiHatSequence,      "xxxxxxxxxxxxxxxxxxxxxxxx");
        strcpy(openHiHatSequence,  "........................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 4:
        // statements
        strcpy(kickSequence,       "x.....x.....x.....x.....");
        strcpy(snareSequence,      "...x.....x.....x.....x..");
        strcpy(hiHatSequence,      ".xxxxxxxxxxxxxxxxxxxxxxx");
        strcpy(openHiHatSequence,  "x.......................");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "........................");
        break;
      case 5:
        // statements
        strcpy(kickSequence,       "x.....x.....x.....x.....");
        strcpy(snareSequence,      "...x.....x.....x.....x..");
        strcpy(hiHatSequence,      ".xxxxxxxxxxx.xxxxxxxxxxx");
        strcpy(openHiHatSequence,  "x...........x...........");
        strcpy(crashSequence,      "x.......................");
        strcpy(rideSequence,       "........................");
        break;
      case 6:
        // statements
        strcpy(kickSequence,       "x.....x.....x.....x.....");
        strcpy(snareSequence,      "...x.....x.....x.....x..");
        strcpy(hiHatSequence,      ".xxxxxxxxxxx.xxxxxxxxx.x");
        strcpy(openHiHatSequence,  "x...........x.........x.");
        strcpy(crashSequence,      "x.......................");
        strcpy(rideSequence,       "x.......................");
        break;
      case 7:
        // statements
        strcpy(kickSequence,       "x.....x.....x.....x.....");
        strcpy(snareSequence,      "...x.....x.....x.....x..");
        strcpy(hiHatSequence,      ".xxxxx.xxxxx.xxxxx.xxxxx");
        strcpy(openHiHatSequence,  "x.....x.....x.....x.....");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "x.......................");
        break;
      case 8:
        // statements
        strcpy(kickSequence,       "x.....x.....x.....x.....");
        strcpy(snareSequence,      "...x.....x.....x.....x..");
        strcpy(hiHatSequence,      ".xxxxx.xxxxx.xxxxx.xxxxx");
        strcpy(openHiHatSequence,  "x.....x.....x.....x.....");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "x...xxx.x.x.x.x.x.x.x.x.");
        break;
      case 9:
        // statements
        strcpy(kickSequence,       "x.....x.....x.....x.....");
        strcpy(snareSequence,      "...x.....x.....x.....x..");
        strcpy(hiHatSequence,      ".xxxxx.xxxxx.xxxxx.xxxxx");
        strcpy(openHiHatSequence,  "x.....x.....x.....x.....");
        strcpy(crashSequence,      "........................");
        strcpy(rideSequence,       "x.x.x.x.x.x.x.x.x.x.x.x.");
        break;
      case 10:
        // statements
        strcpy(kickSequence,       "x.....x.....x.....x.....");
        strcpy(snareSequence,      "...x.....x.....x.....x..");
        strcpy(hiHatSequence,      ".xxxxx.xxxxx.xxxxx.xxxxx");
        strcpy(openHiHatSequence,  "x.....x.....x.....x.....");
        strcpy(crashSequence,      "x.......................");
        strcpy(rideSequence,       "x.x.x.x.x.x.x.x.x.x.x.x.");
        break;
      case 11:
        // statements
        strcpy(kickSequence,       "x.....x.....x.....x.....");
        strcpy(snareSequence,      "...x.....x.....x.....x..");
        strcpy(hiHatSequence,      ".xxxxx.xxxxx.xxxxx.xxxxx");
        strcpy(openHiHatSequence,  "x.....x.....x.....x.....");
        strcpy(crashSequence,      "x...........x.........x.");
        strcpy(rideSequence,       "x.x.x.x.x.x.x.x.x.x.x.x.");
        break;
      default:
        // statements
        break;
    }
  }
  //Jazz
  if (beatType == 3) {
    switch (complexity) {
      case 0:
        // statements
        strcpy(kickSequence,       "x...............");
        strcpy(snareSequence,      "................");
        strcpy(hiHatSequence,      "....x.......x...");
        strcpy(openHiHatSequence,  "................");
        strcpy(crashSequence,      "................");
        strcpy(rideSequence,       "................");

        break;
      case 1:
        // statements
        strcpy(kickSequence,       "x.......x.......");
        strcpy(snareSequence,      "................");
        strcpy(hiHatSequence,      "....x.......x...");
        strcpy(openHiHatSequence,  "................");
        strcpy(crashSequence,      "................");
        strcpy(rideSequence,       "x.......x......x");
        break;
      case 2:
        // statements
        strcpy(kickSequence,       "x...x...x...x...");
        strcpy(snareSequence,      "................");
        strcpy(hiHatSequence,      "....x.......x...");
        strcpy(openHiHatSequence,  "................");
        strcpy(crashSequence,      "................");
        strcpy(rideSequence,       "x...x..xx......x");
        break;
      case 3:
        // statements
        strcpy(kickSequence,       "x...x...x...x...");
        strcpy(snareSequence,      "................");
        strcpy(hiHatSequence,      "....x.......x...");
        strcpy(openHiHatSequence,  "................");
        strcpy(crashSequence,      "................");
        strcpy(rideSequence,       "x...x..xx...x..x");
        break;
      case 4:
        // statements
        strcpy(kickSequence,       "x...x...x...x...");
        strcpy(snareSequence,      "............x...");
        strcpy(hiHatSequence,      "....x.......x...");
        strcpy(openHiHatSequence,  "................");
        strcpy(crashSequence,      "................");
        strcpy(rideSequence,       "x...x..xx...x..x");
        break;
      case 5:
        // statements
        strcpy(kickSequence,       "x...x...x...x...");
        strcpy(snareSequence,      "....x.......x...");
        strcpy(hiHatSequence,      "....x.......x...");
        strcpy(openHiHatSequence,  "................");
        strcpy(crashSequence,      "................");
        strcpy(rideSequence,       "x...x..xx...x..x");
        break;
      case 6:
        // statements
        strcpy(kickSequence,       "x...x...x...x...");
        strcpy(snareSequence,      "....x.......x...");
        strcpy(hiHatSequence,      "....x.......x...");
        strcpy(openHiHatSequence,  "................");
        strcpy(crashSequence,      "................");
        strcpy(rideSequence,       "x...x..xx..xx..x");
        break;
      case 7:
        // statements
        strcpy(kickSequence,       "x...x...x...x...");
        strcpy(snareSequence,      "....x.......x...");
        strcpy(hiHatSequence,      "....x.......x...");
        strcpy(openHiHatSequence,  "...x............");
        strcpy(crashSequence,      "................");
        strcpy(rideSequence,       "x...x..xx..xx..x");
        break;
      case 8:
        // statements
        strcpy(kickSequence,       "x...x...x...x...");
        strcpy(snareSequence,      "....x.......x...");
        strcpy(hiHatSequence,      "....x.......x...");
        strcpy(openHiHatSequence,  "...x.......x....");
        strcpy(crashSequence,      "................");
        strcpy(rideSequence,       "x..xx..xx..xx..x");
        break;
      case 9:
        // statements
        strcpy(kickSequence,       "x...x...x...x...");
        strcpy(snareSequence,      "....x.......x...");
        strcpy(hiHatSequence,      "....x.......x...");
        strcpy(openHiHatSequence,  "...x.......x....");
        strcpy(crashSequence,      "x...............");
        strcpy(rideSequence,       "x..xx..xx..xx..x");
        break;
      case 10:
        // statements
        strcpy(kickSequence,       "x...x...x...x...");
        strcpy(snareSequence,      "....x.......x...");
        strcpy(hiHatSequence,      "....x.......x...");
        strcpy(openHiHatSequence,  "...x.......x....");
        strcpy(crashSequence,      "x.......x.......");
        strcpy(rideSequence,       "x..xx..xx..xx..x");
        break;
      case 11:
        // statements
        strcpy(kickSequence,       "x...x...x...x...");
        strcpy(snareSequence,      "....x.......x...");
        strcpy(hiHatSequence,      "....x.......x...");
        strcpy(openHiHatSequence,  "...x.......x....");
        strcpy(crashSequence,      "x......xx.......");
        strcpy(rideSequence,       "x..xx..xx..xx..x");
        break;
      default:
        // statements
        break;
    }
  }
  //Electronic
  if (beatType == 4) {
    switch (complexity) {
      case 0:
        // Vanilla Ice - Ice Ice Baby
        strcpy(kickSequence,        "x.....x...x...x.");
        strcpy(snareSequence,       "....x.......x...");
        strcpy(hiHatSequence,       "x.x.x.x.x.x.x.x.");
        strcpy(openHiHatSequence,   "................");
        strcpy(crashSequence,       "................");
        strcpy(rideSequence,        "................");
        break;
      case 1:
        // basic
        strcpy(kickSequence,        "x.......x.......");
        strcpy(snareSequence,       "....x.......x...");
        strcpy(hiHatSequence,       "x.x.x.x.x.x.x.x.");
        strcpy(openHiHatSequence,   "................");
        strcpy(crashSequence,       "..........x...x.");
        strcpy(rideSequence,        "............x...");
        break;
      case 2:
        // basic plus
        strcpy(kickSequence,        "x.......x.......");
        strcpy(snareSequence,       "....x.......x...");
        strcpy(hiHatSequence,       ".xx...x.x.x.x.x.");
        strcpy(openHiHatSequence,   "x...x...........");
        strcpy(crashSequence,       "..........x...x.");
        strcpy(rideSequence,        "............x...");
        break;
      case 3:
        // Phil Collins - In the Air Tonight
        strcpy(kickSequence,        "..........x.....");
        strcpy(snareSequence,       "............x...");
        strcpy(hiHatSequence,       "..x...x...x...x.");
        strcpy(openHiHatSequence,   "x...........x...");
        strcpy(crashSequence,       "................");
        strcpy(rideSequence,        "..x...x.........");
        break;
      case 4:
        // Amen Break
        strcpy(kickSequence,        "x.x.......xx....");
        strcpy(snareSequence,       "....x..x.x..x...");
        strcpy(hiHatSequence,       "x.x.x.x.x.x.x.x.");
        strcpy(openHiHatSequence,   "................");
        strcpy(crashSequence,       "................");
        strcpy(rideSequence,        "................");
        break;
      case 5:
        // Genesis Mama
        strcpy(kickSequence,        "x.....x.x.....x.");
        strcpy(snareSequence,       "....x.......x...");
        strcpy(hiHatSequence,       "xxxxxxxxxxx.xxxx");
        strcpy(openHiHatSequence,   "...........x....");
        strcpy(crashSequence,       "................");
        strcpy(rideSequence,        "................");
        break;
      case 6:
        // Genesis - Man on the Corner
        strcpy(kickSequence,        "..x...x.x.x.x...");
        strcpy(snareSequence,       "................");
        strcpy(hiHatSequence,       "x.x.....x.xxx.x.");
        strcpy(openHiHatSequence,   "................");
        strcpy(crashSequence,       "x...x.....x.....");
        strcpy(rideSequence,        "..x....x..xxx.x.");
        break;
      case 7:
        // Marvin Gaye - Sexual Healing
        strcpy(kickSequence,        "x......xx.x.x..x");
        strcpy(snareSequence,       "....x.....xx....");
        strcpy(hiHatSequence,       "x.xxx.x.x.x.x.xx");
        strcpy(openHiHatSequence,   "......x.........");
        strcpy(crashSequence,       "x..x..x.........");
        strcpy(rideSequence,        "..x.............");
        break;
      case 8:
        // Falco - Jeanny
        strcpy(kickSequence,        "x......xx.......");
        strcpy(snareSequence,       "....x.......x...");
        strcpy(hiHatSequence,       "x.x.x.x.x.x.x.x.");
        strcpy(openHiHatSequence,   "................");
        strcpy(crashSequence,       ".....x..........");
        strcpy(rideSequence,        ".x.x............");
        break;
      case 9:
        // Madonna - Vogue
        strcpy(kickSequence,        "x...x...x...x...");
        strcpy(snareSequence,       "....x..x....x...");
        strcpy(hiHatSequence,       "x..xx.x.x..xx.x.");
        strcpy(openHiHatSequence,   "..x.......x.....");
        strcpy(crashSequence,       "................");
        strcpy(rideSequence,        "................");
        break;
      case 10:
        // James Brown - Funky
        strcpy(kickSequence,        "x.x...x...x..x..");
        strcpy(snareSequence,       "....x..x.x.xx..x");
        strcpy(hiHatSequence,       "xxxxxxx.xxxxx.xx");
        strcpy(openHiHatSequence,   ".......x.....x..");
        strcpy(crashSequence,       "................");
        strcpy(rideSequence,        "................");
        break;
      case 11:
        // Mantronix - Needle to the Groove
        strcpy(kickSequence,        "x..x..x.x.......");
        strcpy(snareSequence,       "....x.......x...");
        strcpy(hiHatSequence,       "x.x.x.x.x.x.x.x.");
        strcpy(openHiHatSequence,   ".x.x.x.x.x.x.x.x");
        strcpy(crashSequence,       "..xx..xx.x.x..x.");
        strcpy(rideSequence,        "..x..x..x..x..x.");
        break;
      default:
        // statements
        break;
    }
  }
}

// ***********************
void setinstrumentVolumes(float masterVolume) {
  mixerOut.gain(0, 1.0);                            //From mixerWaves
  mixerOut.gain(1, masterVolume * instrumentVolume[1]);  //Kick
  mixerOut.gain(2, masterVolume * instrumentVolume[2]);  //Snare
  mixerOut.gain(3, 1.0);                            //From mixerDrums
  mixerDrums.gain(0, masterVolume * instrumentVolume[3]);  //Closed Hi Hat
  mixerDrums.gain(1, masterVolume * instrumentVolume[4]);  //Open Hi Hat
  mixerDrums.gain(2, masterVolume * instrumentVolume[5]);  //Crash
  mixerDrums.gain(3, masterVolume * instrumentVolume[6]);  //Ride
  mixerWaves.gain(0, masterVolume * instrumentVolume[7]);  //Main Synth
  mixerWaves.gain(2, masterVolume * instrumentVolume[8]);  //Unison
  mixerWaves.gain(1, masterVolume * instrumentVolume[9]);  //Sub
  // s("masterVolume", masterVolume);
}

// *******************


// === MID  =========================================================================== MIDI
//void checkMIDIin() {
//  if (MIDI.read()) {
//    byte type = MIDI.getType();
//    //something will happen here eventually
//  }
//}

//=== Debug =========================
void s(String txt, float num) {
  Serial.print(txt);
  Serial.print(": ");
  Serial.println(num,5);
}
